: ( 41 char-parse drop drop ; immediate
( now we have comments )

: -- 10 char-parse drop drop ; immediate

-- now we have end of line comments

-- data area allocation
: allot ( bytes -- ) }data + }data& ! ;
: cells ( u -- cell * u ) cell * ;
: ,  ( w -- ) }data ! cell allot ;
: b, ( b -- ) }data !:b 1 allot ;

-- boolean constants
: true ( -- f ) -1 ;
: false ( -- f ) 0 ;

-- abbreviations
: 1+ ( n -- n ) 1 + ;
: 1- ( n -- n) 1 - ;

-- variable abbreviations
: !+ ( addr -- ) dup ? 1+ swap ! ;
: !- ( addr -- ) dup ? 1- swap ! ;

: <0 ( n -- f ) 0 < ;

-- switchs
: on ( addr -- ) true swap ! ;
: off ( addr -- ) false swap ! ;

-- turn immediate mode off in the middle of a definition
: [ ( -- ) immediate-mode on ; immediate
: ] ( -- ) immediate-mode off ;

-- primary flow control words
: ` ( -- xt ) word-parse find-word drop ;
: [`] ( -- ) ` literal ; immediate
: 2literal ( n m -- ) [`] 2lit , , , ;

-- if else endif statements
: source-forward ( -- src ) [`] branch , }data 0 , ;
: [source-forward] ( -- src )  source-forward ; immediate
: source-forward? ( -- src ) [`] branch-false , }data 0 , ;
: [source-forward?] ( -- src ) source-forward? ; immediate

: sink-forward ( src -- ) }data swap ! ;
: [sink-forward] ( src -- ) sink-forward ; immediate

: sink-backward ( -- src ) }data ;
: source-backward ( src -- )  [`] branch , , ;

: if ( -- source-forward ) source-forward?  ; immediate
: else ( source-forward -- source-forward )
            [`] branch , }data 0 , swap }data swap ! ; immediate
: endif ( dest-forward -- ) sink-forward ; immediate
: do ( -- dest-backwards ) sink-backward ; immediate
: repeat ( dest-backwords -- ) swap source-backward sink-forward ; immediate


: ' ( -- c ) word-parse drop ?:b ;
: ['] ( -- )   ' literal ; immediate


: ." ( -- ) ['] " char-parse 1- >output ;

: ]"[ ( -- )  ['] " char-parse 1- tuck }data b-copy drop }data swap dup allot ;
: " ( -- ) source-forward ]"[ rot sink-forward 2literal ; immediate

: hello-world ( -- ) " Hello World!" >output ;
: goodbye-world ( -- ) " goodbye world!" >output ;

: true>output ( -- ) " true" >output ;
: false>output ( -- ) " false" >output ;
: bool. ( f -- ) if true>output else false>output endif ;

: emit ( c -- )   }data ! }data 1 >output ;

: / ( n -- n ) /% drop ;
: % ( n -- u ) /% nip ;
: abs ( n -- u ) abs-sign nip ;
: sign ( n -- n ) abs-sign drop ;
: :q bye ;

: '0 ( -- c ) 48 ;
: 'nl ( -- c ) 10 ;
: 'sp ( -- c ) 32 ;

: digit->char ( u -- c ) '0 + ;

-- start of format buffer
: format{  ( -- addr )  format&{ ? ;
-- start number formatting
: <format ( -- )  }format format&{  ! ;
-- end number formatting
: format> ( -- addr u ) format{ dup }format swap - ;
-- char to format buffer
: char>format ( c -- ) format&{ !- format{ !:b ;
: digit-format ( u -- u ) 10 /% digit->char char>format ;
: digits-format ( u -- ) do digit-format ?dup if repeat ;
: sign-format ( n -- ) <0 if ['] - char>format endif ;
: number->string ( n -- addr u )
      <format
        abs-sign
        digits-format
        sign-format
      format> ;

: . ( n -- ) number->string >output 'sp emit ;

: ds? ( n -- n )  dup . ;
: ds:2? ( x y -- x y ) dup:2 . . ;

: {mem}>output? ( addr u -- )
      do
        dup:2
        if
          ?:b . 1- swap 1+ swap
      repeat
      drop:2 drop ;
